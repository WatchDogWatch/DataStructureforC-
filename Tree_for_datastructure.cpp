/*数是n个节点的有限集，n=0为空树，在任意非空树中，仅有一个特定的称为根的节点root，n>1时，其余节点可以分为m个互不相交的有限集，T1，T2，。。。。Tm，其中每一个集合本身又是一棵树，称为根的子树，subtree*/
/*关键时根节点只有一个，子树可以有无数个，但必须互不相交*/
/*节点拥有的子树数量称为结点的度degree，度为0的节点为叶节点或终端节点，度不为0则为分支节点，非终端节点，除根节点之外，分支节点也成为内部节点，树的度是树内各节点的度的最大值*/
/*度的计算方式看着很简单，就是看该节点有几个分支即可*/
/*节点子树的根(相邻的子节点)称为节点的孩子，该节点是孩子的双亲parent,同一个双亲的孩子称为兄弟sibling，节点祖先是从根到改节点所经分支上的所有结点*/
/*节点层次：从根开始定义，根为第一层，。。。树中节点的最大层次称为树的深度(Depth)或高度*/
/*树的有序性，是指树从左往右是有次序的，不能互换的*/
/*树的表示方法：双亲表示法，孩子表示法，孩子兄弟表示法*/
/*双亲表示法：每个节点，除了自身数据外，还有一个指针指向双亲节点的位置。根节点的指针为-1.(顺序)，因为无法知道子节点，可以增加长子域，指向一个子节点，没有为-1，增加右兄弟域，指向右侧的兄弟节点。没有为-1.*/
/*孩子表示法：多重链表：每个节点有多个指针域(度)，每个指针指向一棵子树的根节点，又叫多重链表表示法。一种是指针域的个数为树的度；2种是专门位置来放每个节点指针域的个数，即度域。
首先把每个节点的孩子节点排列起来，用单链表储存，则n各节点有n个孩子链表。叶子节点的单链表为空，n个头指针有组成一个线性表，采用顺序储存结构，放入一维数组中。
所以孩子链表的数据结构：数据域+指向其下一个孩子节点的指针；表头链表数据结构：数据域+指向其孩子链表表头的指针，树结构：数组储存，用表头结构声明一个节点数组。为了知道节点双亲，可以通过增加一个parent域来指向双亲节点。*/
/*孩子兄弟表示法：数据结构：数据域+第一个孩子指针+右兄弟指针，要查找双亲，可以再增加一个parent指针指向双亲节点，这实质是将其变换为2叉树了。*/
/*
二叉树是n个节点的有限集合，可以是空集，可以是由一个根节点和两棵互不相交的称为左子树和右子树的二叉树组成。
性质：二叉树度不大于2，最多两个子节点，左右节点有顺序，即使一个节点也要区分左右
斜树：所有节点只有左子树的二叉树叫做左斜树，所有节点只有右子树的二叉树叫做右斜树，可以将线性表理解为一种及其特殊的表现形式。
满二叉树:所有节点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树（叶子只能在最下一层，非叶子节点的度一定是2，同深度的树中，满二叉树的节点数和叶子数最多）。
完全二叉树：对一个具有n个节点的二叉树按层序编号，如果节点的编号i与同样深度的满二叉树中i节点在二叉树中的位置完全相同，则二叉树称为完全二叉树。即该二叉树节点的编号与位置与满二叉树中该节点的位置与编号完全一致。
*/
/*二叉树的性质：*/
//1.在二叉树的第i层上最多有2^(i-1)个节点。根节点为第一层。
//2.深度为k的二叉树之多有2^k-1个节点。
//3.对任何一棵二叉树T，如果其终端点节点数为n0，度为2的节点数为n2，则n0=n2+1。
//4.具有n个节点的完全二叉树的深度为log2(n)+1,结果下取整。
//5.如果对一颗有n个节点的完全二叉树的节点按层编号，对任一节点i，有：i=1，该节点为根节点，无双亲；i>1,则其双亲是节点i/2，向下取整；
//5.若2i>n，则节点i无左孩子，i为叶子节点，否则其左孩子为节点2i；如果2i+1>n，则节点i无右孩子，否则其右孩子为2i+1.  即若节点i存在左右子节点，则左子节点为2i，右子节点为2i+1.

//二叉树的储存结构：对于完全二叉树，其标号可以体现节点间的逻辑关系，对于一般二叉树，可以对其按照完全二叉树编号，不存在的节点设为空。所以顺序储存结构（数组）一般只用于保存完全二叉树。
//二叉链表：数据结构:数据域+两个指针域(左右孩子)，还可以增加指向双亲的指针，这成为三叉链表。
#include <iostream>
#include<queue>
#define elementtype char
using namespace std;
#include <string>
typedef struct Node{
    elementtype data;
    Node *lchild;
    Node *rchild;
} Tree;
//二叉树遍历：是指从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。
//遍历方式一般有四种：前序遍历，中序遍历，后序遍历，层序遍历
/*前序遍历*/
//前序遍历：若二叉树为空，则返回空操作，否则首先 访问根节点，然后前序遍历左子树，在前序遍历右子树。（对每一个二叉树节点，先访问父母节点，在访问左子节点，再访问右子节点）
void PreOrderTraverseTree(Tree *T){
    if (T=nullptr){
        return;
    }
    cout<<T->data<<'\n';
    PreOrderTraverseTree(T->lchild);
    PreOrderTraverseTree(T->rchild); 
}
//中序遍历：若树为空，则返回空操作，否则从根节点开始，先中序遍历根节点的左子树，在访问根节点，最后中序遍历右子树。(对每一个二叉树，先访问左子节点，在访问父母节点，最后访问右子节点)
void InOrderTraverse(Tree *T){
    if (T=nullptr)
    return;
    InOrderTraverse(T->lchild);
    cout<<T->data<<'\n';
    InOrderTraverse(T->rchild);
}
//后续遍历：若树为空，则返回空操作，否则从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点。(对于每一个二叉树，先访问左节点，在访问右节点，最后访问父母节点)
void PostOrderTraverse(Tree *T){
    if (T=nullptr)
    return;
    InOrderTraverse(T->lchild);
    InOrderTraverse(T->rchild);
    cout<<T->data<<'\n';
}
//层序遍历：若树为空，则返回空操作，否则从树的第一层根节点开始，由上而下逐层遍历，在同一层中，按从左到右的顺序对节点逐个访问。
//需要用到队列知识，将子节点先储存在队列中，然后依次读出，在依次储存其子节点，从而实现层序遍历。
using namespace std;
/*二叉树结构体，并且构建了有参构造函数*/
struct BinaryTree{
    int vec;
    BinaryTree* left;
    BinaryTree* right;
    BinaryTree(int data)
        :vec(data), left(nullptr), right(nullptr){ 
    }
};
/*队列实现层序遍历*/
void printTree(BinaryTree* arr[])
{
    queue<BinaryTree*> rel; //定义一个队列，数据类型是二叉树指针，不要仅是int！！不然无法遍历
    rel.push(arr[0]);
    while (!rel.empty())
    {
        BinaryTree* front = rel.front();
        printf("%d\n", front->vec);
        rel.pop();                  //删除最前面的节点
        if (front->left != nullptr) //判断最前面的左节点是否为空，不是则放入队列
            rel.push(front->left);  
        if (front->right != nullptr)//判断最前面的右节点是否为空，不是则放入队列
            rel.push(front->right);
    }
}
//二叉树建立
//输入数据时将null的子节点用#代替
//二叉树生成同样有四种方法，通过四种遍历方法实现树的建立
void BuildTree(Tree *TR){
    TR=new Tree;
    char ele;
    cin>>ele;
    if(ele=='#'){
        TR=nullptr;
    }
    else{
        TR->data=ele;
        BuildTree(TR->lchild);
        BuildTree(TR->rchild);
    }      
}
int main(){
    elementtype ele[5];
    int i=0;
   while(i<=5){
       cin>>ele[i];
       i++;
   }
    Tree *T;
    BuildTree(T);
    PreOrderTraverseTree(T);
    system("pause");
    return 1;
}